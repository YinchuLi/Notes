.. role:: raw-math(raw)
    :format: latex html

第2章 基本图形元素生成算法
============================

2.1直线生成算法
-----------------

2.1.1最原始的直线生成算法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2.1.2生成直线的DDA方法
~~~~~~~~~~~~~~~~~~~~~~~~

设(x\ :sub:`1`\, y\ :sub:`1`\)和(x\ :sub:`2`, y\ :sub:`2`\)分别为所求直线的起点和终点坐标，由直线的微分方程：

:raw-math:`$$
\frac { dy }{ dx } =\frac { { y }_{ 2 }-{ y }_{ 1 } }{ { x }_{ 2 }-{ x }_{ 1 } } =\frac { \Delta y }{ \Delta x } =n =直线的斜率
$$`

直线DDA算法的实现

1. 已知直线的两端点坐标：(x\ :sub:`1`\, y\ :sub:`1`\)，(x\ :sub:`2`, y\ :sub:`2`\)
2. 已知画线的颜色：color
3. 计算两个方向的变化量：dx=x2－x1，dy=y2－y1
4. 求出两个方向最大变化量的绝对值：steps=max(|dx|，|dy|)
5. 计算两个方向的增量（考虑生成方向）：xin=dx/steps，yin=dy/steps
6. 设置初始像素坐标：x=x1,y=y1
7. 用循环实现直线的绘制::

	for(i=1; i<=steps; i++) 
	{ putpixel(x，y，color);/*在(x，y)处，以color色画点*/
	  x=x+xin;
	  y=y+yin;
	 } 

直线DDA算法特点：

 该算法简单，实现容易，但由于在循环中涉及实型数的运算，因此生成直线的速度较慢。

直线DDA算法程序::

	#include <math.h>

	void DDALine(int x1, int y1, int x2, int y2, int color)
	{
	　float increx，increy,x,y;
	　int steps,i;

	　if(abs(x2－x1)>abs(y2－y1))
	　　steps= abs(x2－x1);
	　else
	　　steps= abs(y2－y1);

	　increx=(float)(x2－x1)/steps;
	　increy=(float)(y2－y1)/steps;
	　x=x1;
	　y=y1;

	　for(i=1;i<=steps;i++)
	　{
	　　putpixel(x，y，color); //在(x，y)处，以color色画点
	　　x+=increx;
	　　y+=increy;
	　}
	} 
 
2.1.3生成直线的Bresenham算法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2.2直线生成新算法
-------------------

2.2.1对称的快速直线生成算法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2.2.2基于直线链码理论的快速直线生成算法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2.2.3基于直线特性的直线生成集成算法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. 集成算法描述

2. 集成算法与Bresenham算法等绘制直线所需运算量比较

2.2.4自适应多步位移码直线绘制算法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. 直线位移码

2. 单步位移码直线绘制算法

3. 位移码的周期性

4. 自适应的多步位移码直线绘制算法

2.3圆弧生成算法
----------------
2.3.1基于光栅点的圆弧生成算法
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. 圆弧的DDA法

2. Bresenham圆弧生成算法

2.3.2圆弧的多边形逼近算法
~~~~~~~~~~~~~~~~~~~~~~~~~~~

2.4圆弧生成新算法
------------------
2.4.1概述
~~~~~~~~~~

2.4.2水平位移与对角位移
~~~~~~~~~~~~~~~~~~~~~~~~~

2.4.3快速圆弧绘制算法
~~~~~~~~~~~~~~~~~~~~~~~~

2.4.4实验结果分析比较
~~~~~~~~~~~~~~~~~~~~~~~~

