## SOFA: A Multi-Model Framework for Interactive Physcial Simulation ##

## 摘要： ##

Simulation Open Framework Architecture(SOFA)是一个开源的C++库，目地是用于医学仿真上的交互计算。SOFA促进了来自不同领域专家的合作，通过分解复杂的仿真软件为独立设计的组件，然后再以贴图的数据结构进行组织。每一个组件封装仿真中的一个方面，例如自由度，力和约束，微分方程，主循环算法，线性解算器，碰撞检测算法或交互设备。仿真对象能够使用多个模块展现，每一种模块最优化一种不同的任务，例如内应力的计算，碰撞检测，触觉或可视化展示。这些模块在仿真的时候通过使用映射机制能够同步。CPU和GPU的应用可以结合现代硬件架构进行开发。由于这种高效结构的灵活性，SOFA可以用于作为比较模块和算法的实验台，或是作为开发复杂，高性能仿真器的基础。

## 1. 介绍 ##

文章章节按以下方式。第二部分介绍SOFA的多模型结构和基于组件的结构。第三部分详细说明了数据结构用来表示复杂场景，以及数据的存储和传播。高级别的仿真算法，包括ODE解决方案和碰撞检测算法，在第四部分会介绍。然后输入-输出和用户界面会在第五部分给出一个梗概。复杂的仿真例子会在第六部分给出，在第七部分会给出一个简短的结论和展望。

## 2. Multi-Model Represention（多模型表现） ##

考虑在图1所示的可变形肝脏模型。它被不同的解剖的结构所包围着（包括膜片、肋骨、胃和肠），同样的它也和抓手接触（作为一个铰接的刚性链条模型）。在SOFA中，这个肝脏可以使用三种不同的方法仿真。第一种是用来代表它的内部力学行为，这可能会使用Finite Element Method(FEM)或其它方法进行计算。计算内应力的模型几何体会被最优化，尤其使用一个简化数量的四面体来加速和稳定。然而，碰撞过程中精度和速度最好的权衡可能需要另一个几何模型，然而真实的可视化需要一个平整和更细致的几何体。我们因此使用第二个模型用于碰撞检测和响应，然后第三个模块专用于可视化渲染过程。这一部分展示这些模型和它们的连接。
 
## 3.Data Structure（数据结构） ##

仿真数据的组织是一个复杂的问题。我们已经认定了三种有关的层级，然后对于每一个层级提出了不同的解决方案。主要的结构是一个贴图，用于分层组织对象组和它们不同的方法。此外，相互依赖的网络组件属性能够被创建。最后，几何模型和拓扑的改变值得特别的注意。

**3.1贴图和Visitors**

场景的主要节点是用贴图节点来定义的，这用于不同的目地。它们用于集合关联在同一DOFs或拓扑的组件。DoFs的连接是通过和必须位于不同节点下的动力学层级的一个映射，然后在层级中，比起从属，master必须作为父的或更高节点，为了保证它是第一个穿过在visitor自上而下遍历时。贴图节点也能用来随意的呈现嵌入式对象组，组元素作为组中的子节点。为了应用仿真算法，实施一个高水平的组件，对于一列对象，在一个组中聚集对象是必要的。在组的根部或是层级中的更高层附属组件。子组的嵌套不会影响算法的行为，只要masters比slaves的层级高。在图六所示的例子里，场景包括2个仿真对象，使用不同的时间积分器，碰撞检测组件，一个交互力，和一个显示对象的摄像机。根节点代表整个仿真。它包括两个仿真对象，在每一个的子节点，组件应用到这些对象。刚性对象节点包括刚性对象独立自由度的节点。在这个例子里一个单独的运动框架，组件处理关联的状态矢量（位置、力等），这里只是质量。碰撞球体关联到刚性体，使用RigidMapping称为sphereMapping。对于球体中心需要一个子节点，首先它们不是独立DOFs，但是根据不同的类型、框架和点。可变形对象根据一个单独的仿真节点，仅仅一个图形节点需要用来建模。

在非兄弟节点的连接中例如映射或内应力场需要明确参照。两个对象连接到的公用组节点的组件共享。它们大多数通过发送visitors来处理子节点。然而，由于内部力场根据给出的对象对来确定，它需要指向它们的MechanicalStates。

数据结构是使用visitors处理，下面会讨论，对它们遍历的每一个节点应用虚函数，对它们包含的组件应用虚函数。在简单的贴图框架中，visitors会从外部控制结构如应用的主循环中除去。在SOFA中组件允许暂停目前遍历来发送一个任意数给其他visitors，然后重新开始或删除暂停的visitor。这使我们应用全局算法（尤其是ODE解决或碰撞检测），例如explicit Euler velocity，在组件删除低水平visitors。这个visitors会应用在分开的类中，能够对所有的组件使用。这种scenegraph-visitor方法灵巧的从仿真算法中分离物理模型，和数据流图表对比，数据流图表包含复杂的数据和算法在同样的图表下。更换时间积分器需要替换一个组件在我们的图表中，然而相应的数据流图表需要完全的重写。

对象间的相互作用可以通过惩罚力或是Lagrange乘法器来控制。在所有例子中，一个组件联系两个对象对于几何体建立接触模型是必须的，然后计算相互作用力。这种共享的组件位于它们公用的原始节点。通过惩罚力创建的耦合应该考虑柔性和刚性，根据刚度和时间步长。在这种情况下，每一个对象使用它们自己的可能会不同的ODE solver来动画。这种假定的恒定不变的交互力在每一时间步上是和所有显式时间积分方法兼容的。然而当交互力是刚性的隐式集成对于应用大的时间步而不稳定是必须的。这要求解决包括两个对象的方程系统和它们的相互力。在这种情况下，ODE solver位于相同的初始节点。在这种情况下，和相互作用组件处于同一层级。这对于基于约束的相互作用需要计算Lagrange Multipliers基于交互Jacobians也是一样的。根据方程解算器的超线性时间复杂性，通常对于使用分开的solvers处理独立相互作用组比起一个单独的solvers会更有效。

我们使用visitors应用仿真，遍历图表自上而下和自下而上，调用相应的虚幻数在遍历每一个图表节点时。算法操作在仿真对象上通过得到Visitor类和重载它的虚函数topDown()和bottomUp()来应用。这种方法从组件中隐藏了图表结构（父，子），为了应用更灵活，以及跟好的控制执行模块。此外，各种平行策略能够独立的应用每一个节点上的力学表现。数据结构事实上延长了从严格的层级到定向非循环图表来控制更一般的动力学关系。这种自上而下的节点遍历被pruned，除非所有当前节点的父节点已经被遍历过。那么有多个父节点的节点只遍历一次所有它们的父节点。这种自下而上的遍历是一种逆向的顺序。

以AnimateVisitor为例，它的遍历方法出发时间向前。注意AnimateVisitor的遍历会被pruned，当遇到一个ODE solver。这允许ODE solver控制它的子图，重定义在层级以下的solvers。

**3.2数据和引擎**

组件参数使用数据存储器存储在成员对象，模版化它们代表的属性类型。例如，粒子数索引被FixedConstraint约束存储在一个Data<vector<unsigned>>。这些容器提供了一个反射的API，用于在XML文件中序列化，并且自动在用户界面创建输入输出部件。此外，我们可以创建数据实例间的连接使它们的值同步化。这用来举例，当一个Loader组件从一个文件（例如拓扑，位置，位置，刚度，边界条件）加载多个参数，这被一个或多个组件使用作为输入。在一些例子里，我们需要不仅仅是复制已存在的数值，并且是从一个多个数值中进行计算。这种特性是由Engine组件提供的。Engines包括有输入输出数据，它们的更新方法根据输入计算输出。Lazy评价机制用来递归的标记不是最新的数据值，但是它们在必要时进行验算。例如，根据边界立方体和矢量坐标，一个BoxROI engine计算在立方体中的坐标索引。这些索引可以用来作为FixedConstraint的输入来定义一个固定边界条件。根据这种设计，仿真可以透明的设置不管是来自静态的文件中数据，或是由engines自动生成的。

相互联通的数据对象网络定义了一个数据依赖图表，叠加在贴图上。这种二层图表框架也被其他图形软件使用，如OpenInventor和Maya，engines用来生成动画，使用时间作为输入定期更新状态矢量，然后贴图作为框架层级。这种方法适用于简单的动画通道，例如关键帧查补，但是它不容易作为分支和循环控制结构用于更复杂的物理仿真算法。这也是一种相当底层的表现，本质上在编码每一个计算步要求计算一个给定的数据。因此，我们仅使用engines来应用模型参数间的直接关系，这可能在仿真过程中仍未改变。在SOFA中，状态更新算法应用与组件通信使用贴图visitors。

## 4.Simulation Algorithms （仿真算法） ##

典型的，场景中的大多数组件应用低水平的方法意味着其他少数组件，例如累加力或映射状态向量，它们中的一些执行更抽象的操作来将仿真算法应用到任意场景中，通过过载visitor traversals，然后激励它们自己的visitors。这包括ODE集成，线性方程求解，复杂约束和碰撞检测，以及可能包括应用在GPU上的组件。
 
## 5.Interface (界面) ##

SOFA是一个库能够被任何外部的C++程序调用。这种分布伴随着一个以批处理执行模式的可执行文件，一个简单的Glut窗口，和一个更复杂的基于Qt的图形用户界面（GUI）。这个场景可以程序上的创建或是读取XML文件，就像以下部分所展示的。Gnuplot文件在仿真过程中能够输出，然后能够重放动画或是标绘轨迹曲线。交互可视化能够使用OpenGL、Ogre或OpenSceneGraph执行。几何文件序列也能够输出，创建高质量图片和视频使用state-of-the-art renders。

**5.1场景文件**

场景图的一个有趣特点是它们能够从一个text文件读取或写入。

**5.2用户界面**

GUI主要由一个图形观察器，以及选项卡进行调整视角或显示可选视图，像在这个例子中的场景图那样。在场景图窗口中选取一个组件允许打开它的GUI，进行交互式编辑属性使用专门的小工具。在图形窗口中直接编辑参数还没有应用。在分布中包含的一个应用，Modeler，允许添加或移除节点和组件在图表中，它可以加载或导出XML文件。数据对象用于存储组件属性可以自动的创建组件的GUIs。这些可以定制显示额外特性例如线性解算器的收敛显示在图形右边。GUI能够显示一个图形化的计算时间层次的判断每一个visitor或每一个对象。这对于跟踪call图表也很有用。这个树形图显示两个visitors被剔除在第一个时间步，递归的伴随着它们引发的visitors。

**5.3触觉渲染**

交互式仿真的一个主要特性是用户能够实时的修改计算进程。这对于外科手术仿真很重要：在一个训练过程中，当一个虚拟医学设备和一些soft-tissue模型接触时，瞬间的计算必须要计算出来。这种视觉上的接触反馈能够通过触觉渲染增强，那么器官可以真实感到接触。

对于像SOFA这样的平台来提供触觉有两个主要的问题：第一个是触觉力需要在1kHz计算，然而实时的视觉反馈（没有触觉）要在30Hz。第二是触觉反馈能够人为的添加一些能量在仿真中这会使得不稳定，如果控制不是被动的。

因此目前应用到SOFA中有两种不同的方法。第一个是Virtual Coupling技术，然后另一种，更高级的允许渲染约束。

Virtual Coupling：触觉设备的耦合是双向的：用户应用一些动作或力在设备上，反过来，作用力或动作会传给用户。多数的触觉设备提出一个Impedance耦合：根据API提供的设备位置，这个API请求力的数值从应用中。在这个直接耦合的例子里，仿真能够在开环中作为控制的角色。

这种设计对于期望在虚拟环境中稳定和强健触觉反馈是不适合的。确实结合环境阻抗和用户反应会产生不稳定。为了避免这样虚拟的力学耦合被创造了。它和使用一个damped stiffness在设备上的位置控制和虚拟环境中的仿真位置结合起来。如果非常stiff constraints被仿真，那么通过用户的刚度感知不会是无穷的，但是会符合虚拟连接的刚度。因此，在稳定性和性能上的平衡必须通过调整连接的刚度值来确定。

这种刚度spring被仿真两次。一次在触觉循环，另一次在仿真循环。如果这两次是同步的，那么结果会相同。但是它也可以用于异步方式下：快速更新触觉循环，然后low rates在仿真中。在这种情况下，触觉反馈仍然是稳定的，但是两个循环的延迟产生了人为的阻尼。有一个选择来取消人为的阻尼，如果在仿真中没有检测到阻尼。然后这个选项会产生sticking接触的感觉。virtual coupling技术的主要优点是它能够很容易的应用在所有的SOFA仿真中。主要缺点是这种触觉渲染不是透明的（触觉互动不是和真实互动所产生的感觉一样）。

Constraint-Based Rendering:为解决医学仿真中触觉渲染的一个新颖的方式。这种方式处理医学交互使用适合的力或运动传送模型称为compliant mechanisms。这种机制被表述作为一种基于约束问题，以两种分割的线程运行与不同的频率来解决。第一个线程处理整个仿真包括软组织变形，它可以描述各种医学设备的特定行为，依赖于解决在可变形对象和触觉渲染间的力学交互统一的方法。